/****************************************************************************
Copyright (c) 1996, 2010, Innobase Oy. All Rights Reserved.
Copyright (c) 2024 Sunny Bains. All rights reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/** @file trx/trx0trx.c
The transaction

Created 3/26/1996 Heikki Tuuri
*******************************************************/

#include "trx0trx.h"
#include "api0misc.h"
#include "api0ucode.h"
#include "lock0lock.h"
#include "log0log.h"
#include "os0proc.h"
#include "que0que.h"
#include "read0read.h"
#include "srv0srv.h"
#include "trx0roll.h"
#include "trx0rseg.h"
#include "trx0undo.h"
#include "trx0xa.h"
#include "usr0sess.h"

/* Threads with unknown id. */
os_thread_id_t NULL_THREAD_ID;

Trx::Trx(Trx_sys *trx_sys, Session *sess, void *arg) noexcept : m_client_ctx(arg), m_sess(sess), m_trx_sys(trx_sys) {

  m_op_info = "";
  m_start_time = ::time(nullptr);

  mutex_create(&m_undo_mutex, IF_DEBUG("trx_undo_mutex", ) IF_SYNC_DEBUG(SYNC_TRX_UNDO, ) Current_location());

  m_lock_heap = mem_heap_create_in_buffer(256);

  m_global_read_view_heap = mem_heap_create(256);

#ifdef WITH_XOPEN
  memset(&m_xid, 0, sizeof(m_xid));
  m_xid.formatID = -1;
#endif /* WITH_XOPEN */

  ut_d(m_magic_n = TRX_MAGIC_N);
}

Trx::~Trx() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  if (m_n_client_tables_in_use != 0 || m_client_n_tables_locked != 0) {
    log_err(std::format(
      "Client is freeing a trx instance though Trx::m_n_client_tables_in_use is {}"
      " and Trx::m_client_n_tables_locked is {}.",
      m_n_client_tables_in_use,
      m_client_n_tables_locked
    ));

    log_err(to_string(600));
  }

  ut_a(m_magic_n == TRX_MAGIC_N);

  m_magic_n = 11112222;

  ut_a(m_conc_state == TRX_NOT_STARTED);

  mutex_free(&m_undo_mutex);

  ut_a(m_insert_undo == nullptr);
  ut_a(m_update_undo == nullptr);

  if (m_undo_no_arr) {
    trx_undo_arr_free(m_undo_no_arr);
  }

  ut_a(m_signals.empty());
  ut_a(m_reply_signals.empty());

  ut_a(m_wait_lock == nullptr);
  ut_a(m_wait_thrs.empty());

  ut_a(m_dict_operation_lock_mode == 0);

  if (m_lock_heap != nullptr) {
    mem_heap_free(m_lock_heap);
  }

  ut_a(m_trx_locks.empty());

  if (m_global_read_view_heap) {
    mem_heap_free(m_global_read_view_heap);
  }

  m_global_read_view = nullptr;

  ut_a(m_read_view == nullptr);
}

Trx *Trx::create(Trx_sys *trx_sys, Session *sess, void *arg) noexcept {
  auto ptr = mem_alloc(sizeof(Trx));
  return new (ptr) Trx(trx_sys, sess, arg);
}

void Trx::destroy(Trx *&trx) noexcept {
  call_destructor(trx);
  mem_free(trx);
  trx = nullptr;
}

bool Trx::is_interrupted() const noexcept {
  return trx_is_interrupted(this);
}

bool Trx::start_low(ulint rseg_id) noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  ut_ad(m_magic_n == TRX_MAGIC_N);

  if (m_is_purge) {
    m_id = 0;
    m_conc_state = TRX_ACTIVE;
    m_start_time = time(nullptr);

    return true;
  }

  ut_ad(m_conc_state != TRX_ACTIVE);

  if (rseg_id == ULINT_UNDEFINED) {

    rseg_id = m_trx_sys->trx_assign_rseg();
  }

  m_id = m_trx_sys->get_new_trx_id();

  ut_ad(m_rseg == nullptr);
  m_rseg = m_trx_sys->get_nth_rseg(rseg_id);

  /* The initial value for trx->no: LSN_MAX is used in read_view_open_now: */

  m_no = LSN_MAX;
  m_conc_state = TRX_ACTIVE;
  m_start_time = time(nullptr);

#ifdef WITH_XOPEN
  m_flush_log_later = false;
  m_must_flush_log_later = false;
#endif /* WITH_XOPEN */

  m_trx_sys->m_trx_list.push_front(this);

  return true;
}

void Trx::set_detailed_error(const char *msg) noexcept {
  memcpy(m_detailed_error.data(), msg, m_detailed_error.size() - 1);
}

bool Trx::start(ulint rseg_id) noexcept {
  /* Update the info whether we should skip XA steps that eat CPU time
  For the duration of the transaction trx->m_support_xa is not reread
  from thd so any changes in the value take effect in the next
  transaction. This is to avoid a scenario where some undo
  generated by a transaction, has XA stuff, and other undo,
  generated by the same transaction, doesn't. */

  /* FIXME: This requires an API change to support */
  /* trx->m_support_xa = ib_supports_xa(trx->m_client_ctx); */

  mutex_enter(&m_trx_sys->m_mutex);

  auto ret = start_low(rseg_id);

  mutex_exit(&m_trx_sys->m_mutex);

  return ret;
}

void Trx::commit_off_kernel() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  lsn_t lsn{};
  auto rseg{m_rseg};

  if (m_insert_undo != nullptr || m_update_undo != nullptr) {

    mutex_exit(&m_trx_sys->m_mutex);

    mtr_t mtr;

    mtr.start();

    /* Change the undo log segment states from TRX_UNDO_ACTIVE
    to some other state: these modifications to the file data
    structure define the transaction as committed in the file
    based world, at the serialization point of the log sequence
    number lsn obtained below. */

    mutex_enter(&rseg->mutex);

    if (m_insert_undo != nullptr) {
      srv_undo->set_state_at_finish(rseg, this, m_insert_undo, &mtr);
    }

    auto undo = m_update_undo;

    if (undo != nullptr) {
      mutex_enter(&m_trx_sys->m_mutex);
      m_no = m_trx_sys->get_new_trx_no();

      mutex_exit(&m_trx_sys->m_mutex);

      /* It is not necessary to obtain trx->undo_mutex here
      because only a single OS thread is allowed to do the
      transaction commit for this transaction. */

      auto update_hdr_page = srv_undo->set_state_at_finish(rseg, this, undo, &mtr);

      /* We have to do the cleanup for the update log while
      holding the rseg mutex because update log headers
      have to be put to the history list in the order of
      the trx number. */

      srv_undo->update_cleanup(this, update_hdr_page, &mtr);
    }

    mutex_exit(&rseg->mutex);

    /* The following call commits the mini-transaction, making the
    whole transaction committed in the file-based world, at this
    log sequence number. The transaction becomes 'durable' when
    we write the log to disk, but in the logical sense the commit
    in the file-based data structures (undo logs etc.) happens
    here.

    NOTE that transaction numbers, which are assigned only to
    transactions with an update undo log, do not necessarily come
    in exactly the same order as commit lsn's, if the transactions
    have different rollback segments. To get exactly the same
    order we should hold the kernel mutex up to this point,
    adding to the contention of the kernel mutex. However, if
    a transaction T2 is able to see modifications made by
    a transaction T1, T2 will always get a bigger transaction
    number and a bigger commit lsn than T1. */

    mtr.commit();

    lsn = mtr.m_end_lsn;

    mutex_enter(&m_trx_sys->m_mutex);
  }

  ut_ad(m_conc_state == TRX_ACTIVE || m_conc_state == TRX_PREPARED);
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  /* The following assignment makes the transaction committed in memory
  and makes its changes to data visible to other transactions.
  NOTE that there is a small discrepancy from the strict formal
  visibility rules here: a human user of the database can see
  modifications made by another transaction T even before the necessary
  log segment has been flushed to the disk. If the database happens to
  crash before the flush, the user has seen modifications from T which
  will never be a committed transaction. However, any transaction T2
  which sees the modifications of the committing transaction T, and
  which also itself makes modifications to the database, will get an lsn
  larger than the committing transaction T. In the case where the log
  flush fails, and T never gets committed, also T2 will never get
  committed. */

  m_conc_state = TRX_COMMITTED_IN_MEMORY;

  /* If we release m_trx_sys->m_mutex below and we are still doing
  recovery i.e.: back ground rollback thread is still active
  then there is a chance that the rollback thread may see
  this trx as COMMITTED_IN_MEMORY and goes adhead to clean it
  up calling trx_cleanup_at_db_startup(). This can happen
  in the case we are committing a trx here that is left in
  PREPARED state during the crash. Note that commit of the
  rollback of a PREPARED trx happens in the recovery thread
  while the rollback of other transactions happen in the
  background thread. To avoid this race we unconditionally
  unset the m_is_recovered flag from the trx. */

  m_is_recovered = false;

  srv_lock_sys->release_off_trx_sys_mutex(this);

  if (m_global_read_view != nullptr) {
    read_view_close(m_global_read_view);
    mem_heap_empty(m_global_read_view_heap);
    m_global_read_view = nullptr;
  }

  m_read_view = nullptr;

  if (lsn > 0) {

    mutex_exit(&m_trx_sys->m_mutex);

    if (m_insert_undo != nullptr) {
      srv_undo->insert_cleanup(this);
    }

    /* NOTE that we could possibly make a group commit more
    efficient here: call os_thread_yield here to allow also other
    trxs to come to commit! */

    /* Depending on the config options, we may now write the log
    buffer to the log files, making the transaction durable if
    the OS does not crash. We may also flush the log files to
    disk, making the transaction durable also at an OS crash or a
    power outage.

    The idea in InnoDB's group commit is that a group of
    transactions gather behind a trx doing a physical disk write
    to log files, and when that physical write has been completed,
    one of those transactions does a write which commits the whole
    group. Note that this group commit will only bring benefit if
    there are > 2 users in the database. Then at least 2 users can
    gather behind one doing the physical log write to disk. */

    /* If we are calling trx_commit() under prepare_commit_mutex, we
    will delay possible log write and flush to a separate function
    trx_commit_flush_log(), which is only called when the
    thread has released the mutex. This is to make the
    group commit algorithm to work. Otherwise, the prepare_commit
    mutex would serialize all commits and prevent a group of
    transactions from gathering. */

    auto log = m_trx_sys->m_fsp->m_log;

#ifdef WITH_XOPEN
    if (m_flush_log_later) {
      /* Do nothing yet */
      m_must_flush_log_later = true;
    } else
#endif /* WITH_XOPEN */
      if (srv_config.m_flush_log_at_trx_commit == 0) {
        /* Do nothing */
      } else if (srv_config.m_flush_log_at_trx_commit == 1) {
        if (srv_config.m_unix_file_flush_method == SRV_UNIX_NOSYNC) {
          /* Write the log but do not flush it to disk */
          log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, false);
        } else {
          /* Write the log to the log files AND flush them to disk */
          log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, true);
        }
      } else if (srv_config.m_flush_log_at_trx_commit == 2) {
        /* Write the log but do not flush it to disk */
        log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, false);
      } else {
        ut_error;
      }

    m_commit_lsn = lsn;

    /*-------------------------------------*/

    mutex_enter(&m_trx_sys->m_mutex);
  }

  /* Free all savepoints */
  trx_roll_free_all_savepoints(this);

  m_undo_no = 0;
  m_rseg = nullptr;
  m_client_query_str = nullptr;
  m_conc_state = TRX_NOT_STARTED;
  m_last_sql_stat_start.least_undo_no = 0;

  ut_ad(m_wait_thrs.empty());
  ut_ad(m_trx_locks.empty());

  m_trx_sys->m_trx_list.remove(this);
}

void Trx::cleanup_at_db_startup() noexcept {
  if (m_insert_undo != nullptr) {
    srv_undo->insert_cleanup(this);
  }

  m_undo_no = 0;
  m_rseg = nullptr;
  m_conc_state = TRX_NOT_STARTED;
  m_last_sql_stat_start.least_undo_no = 0;

  m_trx_sys->m_trx_list.remove(this);
}

read_view_t *Trx::assign_read_view() noexcept {
  ut_ad(m_conc_state == TRX_ACTIVE);

  if (m_read_view != nullptr) {
    return m_read_view;
  }

  mutex_enter(&m_trx_sys->m_mutex);

  if (m_read_view == nullptr) {
    m_read_view = read_view_open_now(m_id, m_global_read_view_heap);
    m_global_read_view = m_read_view;
  }

  mutex_exit(&m_trx_sys->m_mutex);

  return m_read_view;
}

void Trx::handle_commit_sig_off_kernel(que_thr_t *&next_thr) noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  m_que_state = TRX_QUE_COMMITTING;

  commit_off_kernel();

  ut_ad(m_wait_thrs.empty());

  /* Remove all TRX_SIG_COMMIT signals from the signal queue
  and send reply messages to them */

  auto sig = m_signals.front();

  while (sig != nullptr) {
    auto next_sig = sig->next();

    if (sig->type == TRX_SIG_COMMIT) {
      sig_reply(sig, next_thr);
      sig_remove(sig);
    }

    sig = next_sig;
  }

  m_que_state = TRX_QUE_RUNNING;
}

void Trx::end_lock_wait() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));
  ut_ad(m_que_state == TRX_QUE_LOCK_WAIT);

  for (auto thr = m_wait_thrs.front(); thr != nullptr; thr = m_wait_thrs.front()) {
    que_thr_end_wait_no_next_thr(thr);
    m_wait_thrs.remove(thr);
  }

  m_que_state = TRX_QUE_RUNNING;
}

void Trx::lock_wait_to_suspended() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));
  ut_ad(m_que_state == TRX_QUE_LOCK_WAIT);

  for (auto thr = m_wait_thrs.front(); thr != nullptr; thr = m_wait_thrs.front()) {
    thr->state = QUE_THR_SUSPENDED;

    m_wait_thrs.remove(thr);
  }

  m_que_state = TRX_QUE_RUNNING;
}

void Trx::sig_reply_wait_to_suspended() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  for (auto sig = m_reply_signals.front(); sig != nullptr; sig = m_reply_signals.front()) {
    auto thr = sig->receiver;

    ut_ad(thr->state == QUE_THR_SIG_REPLY_WAIT);

    thr->state = QUE_THR_SUSPENDED;

    sig->receiver = nullptr;

    m_reply_signals.remove(sig);
  }
}

bool Trx::sig_is_compatible(ulint type, ulint sender) noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  if (m_signals.empty()) {

    return true;
  }

  if (sender == TRX_SIG_SELF) {
    if (type == TRX_SIG_ERROR_OCCURRED) {
      return true;
    } else {
      return type == TRX_SIG_BREAK_EXECUTION;
    }
  }

  ut_ad(sender == TRX_SIG_OTHER_SESS);

  if (type == TRX_SIG_COMMIT) {

    for (auto sig : m_signals) {
      if (sig->type == TRX_SIG_TOTAL_ROLLBACK) {
        return false;
      }
    }

    return true;

  } else if (type == TRX_SIG_TOTAL_ROLLBACK) {

    for (auto sig : m_signals) {
      if (sig->type == TRX_SIG_COMMIT) {
        return false;
      }
    }

    return true;

  } else if (type == TRX_SIG_BREAK_EXECUTION) {
    return true;
  } else {
    ut_error;
    return false;
  }
}

void Trx::sig_send(ulint type, ulint sender, que_thr_t *receiver_thr, trx_savept_t *savept, que_thr_t *&next_thr) noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  trx_sig_t *sig;
  Trx *receiver_trx;

  if (!sig_is_compatible(type, sender)) {
    /* The signal is not compatible with the other signals in
    the queue: die */

    ut_error;
  }

  /* Queue the signal object */

  if (m_signals.empty()) {
    /* The signal list is empty: the 'sig' slot must be unused
    (we improve performance a bit by avoiding mem_alloc) */
    sig = &m_sig;
  } else {
    /* It might be that the 'sig' slot is unused also in this
    case, but we choose the easy way of using mem_alloc */
    sig = static_cast<trx_sig_t *>(mem_alloc(sizeof(trx_sig_t)));
  }

  m_signals.push_back(sig);

  sig->type = type;
  sig->sender = sender;
  sig->receiver = receiver_thr;

  if (savept != nullptr) {
    sig->savept = *savept;
  }

  if (receiver_thr != nullptr) {
    receiver_trx = thr_get_trx(receiver_thr);

    receiver_trx->m_reply_signals.push_back(sig);
  }

  if (m_sess->m_state == Session::State::ERROR) {

    sig_reply_wait_to_suspended();
  }

  if ((sender != TRX_SIG_SELF) || (type == TRX_SIG_BREAK_EXECUTION)) {
    ut_error;
  }

  /* If there were no other signals ahead in the queue, try to start
  handling of the signal */

  if (m_signals.front() == sig) {

    sig_start_handling(next_thr);
  }
}

void Trx::end_signal_handling() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));
  ut_ad(m_handling_signals == true);

  m_handling_signals = false;

  m_graph = m_graph_before_signal_handling;

  if (m_graph != nullptr && m_sess->m_state == Session::State::ERROR) {

    que_fork_error_handle(this, m_graph);
  }
}

void Trx::sig_start_handling(que_thr_t *&next_thr) noexcept {
  for (;;) {
    /* We loop in this function body as long as there are queued signals
    we can process immediately */

    ut_ad(mutex_own(&m_trx_sys->m_mutex));

    if (m_handling_signals && m_signals.empty()) {

      end_signal_handling();

      return;
    }

    if (m_conc_state == TRX_NOT_STARTED) {

      auto success = start_low(ULINT_UNDEFINED);
      ut_a(success);
    }

    /* If the trx is in a lock wait state, moves the waiting query threads
    to the suspended state */

    if (m_que_state == TRX_QUE_LOCK_WAIT) {

      lock_wait_to_suspended();
    }

    /* If the session is in the error state and this trx has threads
    waiting for reply from signals, moves these threads to the suspended
    state, canceling wait reservations; note that if the transaction has
    sent a commit or rollback signal to itself, and its session is not in
    the error state, then nothing is done here. */

    if (m_sess->m_state == Session::State::ERROR) {
      sig_reply_wait_to_suspended();
    }

    /* If there are no running query threads, we can start processing of a
    signal, otherwise we have to wait until all query threads of this
    transaction are aware of the arrival of the signal. */

    if (m_n_active_thrs > 0) {

      return;
    }

    if (m_handling_signals == 0) {
      m_graph_before_signal_handling = m_graph;

      m_handling_signals = true;
    }

    auto sig = m_signals.front();
    auto type = sig->type;

    if (type == TRX_SIG_COMMIT) {

      handle_commit_sig_off_kernel(next_thr);

    } else if (type == TRX_SIG_TOTAL_ROLLBACK || type == TRX_SIG_ROLLBACK_TO_SAVEPT) {

      trx_rollback(this, sig, &next_thr);

      /* No further signals can be handled until the rollback
      completes, therefore we return */

    } else if (type == TRX_SIG_ERROR_OCCURRED) {

      trx_rollback(this, sig, &next_thr);

      /* No further signals can be handled until the rollback
      completes, therefore we return */

    } else if (type == TRX_SIG_BREAK_EXECUTION) {

      sig_reply(sig, next_thr);
      sig_remove(sig);

    } else {
      ut_error;
    }
  }
}

void Trx::sig_reply(trx_sig_t *sig, que_thr_t *&next_thr) noexcept {
  ut_ad(mutex_own(&srv_trx_sys->m_mutex));

  if (sig->receiver != nullptr) {
    ut_ad(sig->receiver->state == QUE_THR_SIG_REPLY_WAIT);

    auto receiver_trx = thr_get_trx(sig->receiver);

    receiver_trx->m_reply_signals.remove(sig);
    ut_ad(receiver_trx->m_sess->m_state != Session::State::ERROR);

    que_thr_end_wait(sig->receiver, &next_thr);

    sig->receiver = nullptr;
  }
}

void Trx::sig_remove(trx_sig_t *&sig) noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));
  ut_ad(sig->receiver == nullptr);

  m_signals.remove(sig);

  sig->type = 0;

  if (sig != &m_sig) {
    mem_free(sig);
    sig = nullptr;
  }
}

Commit_node *Trx::commit_node_create(mem_heap_t *heap) noexcept {
  auto ptr = mem_heap_alloc(heap, sizeof(Commit_node));
  auto node = new (ptr) Commit_node();

  node->state = COMMIT_NODE_SEND;
  node->common.type = QUE_NODE_COMMIT;

  return node;
}

que_thr_t *Trx::commit_step(que_thr_t *thr) noexcept {
  auto node = static_cast<Commit_node *>(thr->run_node);

  ut_ad(que_node_get_type(node) == QUE_NODE_COMMIT);

  if (thr->prev_node == que_node_get_parent(node)) {
    node->state = COMMIT_NODE_SEND;
  }

  if (node->state == COMMIT_NODE_SEND) {
    auto trx = thr_get_trx(thr);

    mutex_enter(&trx->m_trx_sys->m_mutex);

    node->state = COMMIT_NODE_WAIT;

    que_thr_t *next_thr{};

    thr->state = QUE_THR_SIG_REPLY_WAIT;

    /* Send the commit signal to the transaction */

    trx->sig_send(TRX_SIG_COMMIT, TRX_SIG_SELF, thr, nullptr, next_thr);

    mutex_exit(&trx->m_trx_sys->m_mutex);

    return next_thr;
  }

  ut_ad(node->state == COMMIT_NODE_WAIT);

  node->state = COMMIT_NODE_SEND;

  thr->run_node = que_node_get_parent(node);

  return thr;
}

db_err Trx::commit() noexcept {
  /* Because we do not do the commit by sending an Innobase
  sig to the transaction, we must here make sure that trx has been
  started. */

  m_op_info = "committing";

  mutex_enter(&m_trx_sys->m_mutex);

  commit_off_kernel();

  mutex_exit(&m_trx_sys->m_mutex);

  m_op_info = "";

  return DB_SUCCESS;
}

void Trx::mark_sql_stat_end() noexcept {
  if (m_conc_state == TRX_NOT_STARTED) {
    m_undo_no = 0;
  }

  m_last_sql_stat_start.least_undo_no = m_undo_no;
}

ulint Trx::number_of_rows_locked() const noexcept {
  ulint n_records{};

  for (auto lock : m_trx_locks) {
    if (lock->type() == LOCK_REC) {
      const auto n_bits = lock->rec_get_n_bits();

      for (ulint i{}; i < n_bits; ++i) {
        if (lock->rec_is_nth_bit_set(i)) {
          ++n_records;
        }
      }
    }
  }

  return n_records;
}

[[nodiscard]] std::string Trx::to_string(ulint max_query_len) const noexcept {
  std::ostringstream os;

  os << "TRANSACTION " << m_id;

  const auto active_time = difftime(time(nullptr), m_start_time);

  switch (m_conc_state) {
    case TRX_NOT_STARTED:
      os << ", not started";
      break;
    case TRX_ACTIVE:
      os << ", ACTIVE " << active_time << " secs";
      break;
    case TRX_PREPARED:
      os << ", ACTIVE (PREPARED) " << active_time << " secs";
      break;
    case TRX_COMMITTED_IN_MEMORY:
      os << ", COMMITTED IN MEMORY";
      break;
    default:
      os << " state " << (ulong)m_conc_state;
  }

  if (*m_op_info) {
    os << m_op_info;
  }

  if (m_is_recovered) {
    os << " recovered trx";
  }

  if (m_is_purge) {
    os << " purge trx";
  }

  os << "\n";

  if (m_n_client_tables_in_use > 0 || m_client_n_tables_locked > 0) {
    os << std::format("Client tables in use {}, locked {}\n", m_n_client_tables_in_use, m_client_n_tables_locked);
  }

  switch (m_que_state) {
    case TRX_QUE_RUNNING:
      break;
    case TRX_QUE_LOCK_WAIT:
      os << "LOCK WAIT ";
      break;
    case TRX_QUE_ROLLING_BACK:
      os << "ROLLING BACK ";
      break;
    case TRX_QUE_COMMITTING:
      os << "COMMITTING ";
      break;
    default:
      os << "que state " << (ulong)m_que_state;
  }

  if (!m_trx_locks.empty() || mem_heap_get_size(m_lock_heap) > 400) {

    os << std::format(
      "{} lock struct(s), heap size {}, {} row lock(s)", m_trx_locks.size(), mem_heap_get_size(m_lock_heap), number_of_rows_locked()
    );
  }

  if (m_undo_no > 0) {
    os << ", undo log entries " << m_undo_no;
  }

  os << "\n";

  return os.str();
}

int Trx::weight_cmp(const Trx *lhs, const Trx *rhs) noexcept {
  /* We compare the number of altered/locked rows. */
  return lhs->weight() - rhs->weight();
}

void Trx::prepare_for_commit() noexcept {
  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  lsn_t lsn{};
  auto rseg = m_rseg;

  if (m_insert_undo != nullptr || m_update_undo != nullptr) {
    mutex_exit(&m_trx_sys->m_mutex);

    mtr_t mtr;

    mtr.start();

    /* Change the undo log segment states from TRX_UNDO_ACTIVE
    to TRX_UNDO_PREPARED: these modifications to the file data
    structure define the transaction as prepared in the
    file-based world, at the serialization point of lsn. */

    mutex_enter(&rseg->mutex);

    if (m_insert_undo != nullptr) {

      /* It is not necessary to obtain m_undo_mutex here
      because only a single OS thread is allowed to do the
      transaction prepare for this transaction. */

      srv_undo->set_state_at_prepare(this, m_insert_undo, &mtr);
    }

    if (m_update_undo != nullptr) {
      srv_undo->set_state_at_prepare(this, m_update_undo, &mtr);
    }

    mutex_exit(&rseg->mutex);

    /* This mtr commit makes the transaction prepared in the file-based world */
    mtr.commit();

    lsn = mtr.m_end_lsn;

    mutex_enter(&m_trx_sys->m_mutex);
  }

  ut_ad(mutex_own(&m_trx_sys->m_mutex));

  m_conc_state = TRX_PREPARED;

  if (lsn > 0) {
    /* Depending on the config options, we may now write the log
    buffer to the log files, making the prepared state of the
    transaction durable if the OS does not crash. We may also
    flush the log files to disk, making the prepared state of the
    transaction durable also at an OS crash or a power outage.

    The idea in InnoDB's group prepare is that a group of
    transactions gather behind a trx doing a physical disk write
    to log files, and when that physical write has been completed,
    one of those transactions does a write which prepares the whole
    group. Note that this group prepare will only bring benefit if
    there are > 2 users in the database. Then at least 2 users can
    gather behind one doing the physical log write to disk. */

    mutex_exit(&m_trx_sys->m_mutex);

    auto log = m_trx_sys->m_fsp->m_log;

    if (srv_config.m_flush_log_at_trx_commit == 0) {
      /* Do nothing */
    } else if (srv_config.m_flush_log_at_trx_commit == 1) {
      if (srv_config.m_unix_file_flush_method == SRV_UNIX_NOSYNC) {
        /* Write the log but do not flush it to disk */
        log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, false);
      } else {
        /* Write the log to the log files AND flush them to disk */
        log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, true);
      }
    } else if (srv_config.m_flush_log_at_trx_commit == 2) {
      /* Write the log but do not flush it to disk */
      log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, false);
    } else {
      ut_error;
    }

    mutex_enter(&m_trx_sys->m_mutex);
  }
}

ulint Trx::prepare() noexcept {
  /* Because we do not do the prepare by sending an Innobase
  sig to the transaction, we must here make sure that trx has been
  started. */

  m_op_info = "preparing";

  mutex_enter(&m_trx_sys->m_mutex);

  prepare_for_commit();

  mutex_exit(&m_trx_sys->m_mutex);

  m_op_info = "";

  return 0;
}

#ifdef WITH_XOPEN
ulint Trx::commit_flush_log() noexcept {
  const auto lsn = m_commit_lsn;
  auto log = m_trx_sys->m_fsp->m_log;

  m_op_info = "flushing log";

  if (!m_must_flush_log_later) {
    /* Do nothing */
  } else if (srv_config.m_flush_log_at_trx_commit == 0) {
    /* Do nothing */
  } else if (srv_config.m_flush_log_at_trx_commit == 1) {
    if (srv_config.m_unix_file_flush_method == SRV_UNIX_NOSYNC) {
      /* Write the log but do not flush it to disk */
      log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, false);
    } else {
      /* Write the log to the log files AND flush them to disk */
      log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, true);
    }
  } else if (srv_config.m_flush_log_at_trx_commit == 2) {
    /* Write the log but do not flush it to disk */
    log->write_up_to(lsn, LOG_WAIT_ONE_GROUP, false);
  } else {
    ut_error;
  }

  m_must_flush_log_later = false;

  m_op_info = "";

  return 0;
}
#endif /* WITH_XOPEN */
